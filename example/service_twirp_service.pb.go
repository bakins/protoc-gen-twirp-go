// Code generated by protoc-gen-twirp-go DO NOT EDIT.
package example

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strconv"
	"strings"
	"sync"

	jsoniter "github.com/json-iterator/go"
	"github.com/twitchtv/twirp"
	"github.com/twitchtv/twirp/ctxsetters"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
)

var jsonCodec = jsoniter.ConfigCompatibleWithStandardLibrary

var twirpBufferPool = sync.Pool{
	New: func() interface{} {
		return &bytes.Buffer{}
	},
}

type TwirpCodec interface {
	ContentType() string
	MarshalTo(context.Context, proto.Message, io.Writer) error
	UnmarshalFrom(context.Context, proto.Message, io.Reader) error
}

type TwirpCodecProtobuf struct {
	proto.UnmarshalOptions
	proto.MarshalOptions
}

var DefaultTwirpCodecProtobuf = &TwirpCodecProtobuf{}

func (t *TwirpCodecProtobuf) ContentType() string {
	return "application/protobuf"
}

func (t *TwirpCodecProtobuf) MarshalTo(_ context.Context, m proto.Message, w io.Writer) error {
	data, err := t.MarshalOptions.Marshal(m)
	if err != nil {
		return err
	}

	_, err = w.Write(data)
	return err
}

func (t *TwirpCodecProtobuf) UnmarshalFrom(_ context.Context, m proto.Message, r io.Reader) error {
	buff := twirpBufferPool.Get().(*bytes.Buffer)
	defer twirpBufferPool.Put(buff)

	buff.Reset()

	if _, err := io.Copy(buff, r); err != nil {
		return err
	}

	return t.UnmarshalOptions.Unmarshal(buff.Bytes(), m)
}

type TwirpCodecJson struct {
	protojson.MarshalOptions
	protojson.UnmarshalOptions
}

var DefaultTwirpCodecJson = &TwirpCodecJson{
	MarshalOptions: protojson.MarshalOptions{
		UseProtoNames:   true,
		EmitUnpopulated: true,
	},
}

func (t *TwirpCodecJson) ContentType() string {
	return "application/json"
}

func (t *TwirpCodecJson) MarshalTo(_ context.Context, m proto.Message, w io.Writer) error {
	data, err := t.MarshalOptions.Marshal(m)
	if err != nil {
		return err
	}

	_, err = w.Write(data)
	return err
}

func (t *TwirpCodecJson) UnmarshalFrom(_ context.Context, m proto.Message, r io.Reader) error {
	buff := twirpBufferPool.Get().(*bytes.Buffer)
	defer twirpBufferPool.Put(buff)

	buff.Reset()

	if _, err := io.Copy(buff, r); err != nil {
		return err
	}

	return t.UnmarshalOptions.Unmarshal(buff.Bytes(), m)
}

type TwirpServerOptions struct {
	codecs map[string]TwirpCodec
}

type TwirpServerOption func(*TwirpServerOptions)

func WithTwirpServerCodec(codec TwirpCodec) TwirpServerOption {
	return func(o *TwirpServerOptions) {
		o.codecs[codec.ContentType()] = codec
	}
}

type TwirpClientOptions struct {
	codec TwirpCodec
}

type TwirpClientOption func(*TwirpClientOptions)

func WithTwirpClientCodec(codec TwirpCodec) TwirpClientOption {
	return func(o *TwirpClientOptions) {
		o.codec = codec
	}
}

func twirpCallRequestReceived(ctx context.Context, h *twirp.ServerHooks) (context.Context, error) {
	if h == nil || h.RequestReceived == nil {
		return ctx, nil
	}
	return h.RequestReceived(ctx)
}

func twirpCallRequestRouted(ctx context.Context, h *twirp.ServerHooks) (context.Context, error) {
	if h == nil || h.RequestRouted == nil {
		return ctx, nil
	}
	return h.RequestRouted(ctx)
}

func twirpErrFromPanic(p interface{}) error {
	if err, ok := p.(error); ok {
		return err
	}
	return fmt.Errorf("panic: %v", p)
}

func twirpEnsurePanicResponses(ctx context.Context, resp http.ResponseWriter, hooks *twirp.ServerHooks) {
	if r := recover(); r != nil {
		err := twirpErrFromPanic(r)
		twerr := twirp.NewError(twirp.Internal, "Internal service panic")
		twerr = twirp.WrapError(twerr, err)

		twirpWriteError(ctx, resp, twerr, hooks)

		f, ok := resp.(http.Flusher)
		if ok {
			f.Flush()
		}

		panic(r)
	}
}

func twirpWriteError(ctx context.Context, resp http.ResponseWriter, err error, hooks *twirp.ServerHooks) {
	twerr, ok := err.(twirp.Error)
	if !ok {
		twerr = twirp.InternalErrorWith(err)
	}

	statusCode := twirp.ServerHTTPStatusFromErrorCode(twerr.Code())
	ctx = ctxsetters.WithStatusCode(ctx, statusCode)
	ctx = twirpCallError(ctx, hooks, twerr)

	respBody := twirpMarshalErrorToJSON(twerr)

	resp.Header()["Content-Type"] = []string{"application/json"}
	resp.WriteHeader(statusCode)

	_, _ = resp.Write(respBody)

	twirpCallResponseSent(ctx, hooks)
}

func twirpCallError(ctx context.Context, h *twirp.ServerHooks, err twirp.Error) context.Context {
	if h == nil || h.Error == nil {
		return ctx
	}
	return h.Error(ctx, err)
}

func twirpCallResponseSent(ctx context.Context, h *twirp.ServerHooks) {
	if h == nil || h.ResponseSent == nil {
		return
	}
	h.ResponseSent(ctx)
}

type twirpErrorJSON struct {
	Meta map[string]string `json:"meta,omitempty"`
	Code string            `json:"code"`
	Msg  string            `json:"msg"`
}

func twirpMarshalErrorToJSON(twerr twirp.Error) []byte {
	// make sure that msg is not too large
	msg := twerr.Msg()
	if len(msg) > 1e6 {
		msg = msg[:1e6]
	}

	tj := twirpErrorJSON{
		Code: string(twerr.Code()),
		Msg:  msg,
		Meta: twerr.MetaMap(),
	}

	buf, err := jsonCodec.Marshal(&tj)
	if err != nil {
		buf = []byte("{\"type\": \"" + twirp.Internal + "\", \"msg\": \"There was an error but it could not be serialized into JSON\"}") // fallback
	}

	return buf
}

func twirpCallResponsePrepared(ctx context.Context, h *twirp.ServerHooks) context.Context {
	if h == nil || h.ResponsePrepared == nil {
		return ctx
	}
	return h.ResponsePrepared(ctx)
}

func twirpCallClientResponseReceived(ctx context.Context, h *twirp.ClientHooks) {
	if h == nil || h.ResponseReceived == nil {
		return
	}
	h.ResponseReceived(ctx)
}

func twirpCallClientRequestPrepared(ctx context.Context, h *twirp.ClientHooks, req *http.Request) (context.Context, error) {
	if h == nil || h.RequestPrepared == nil {
		return ctx, nil
	}
	return h.RequestPrepared(ctx, req)
}

func twirpCallClientError(ctx context.Context, h *twirp.ClientHooks, err twirp.Error) {
	if h == nil || h.Error == nil {
		return
	}
	h.Error(ctx, err)
}

func twirpErrorFromResponse(resp *http.Response) twirp.Error {
	statusCode := resp.StatusCode
	statusText := http.StatusText(statusCode)

	if statusCode >= 300 && statusCode <= 399 {
		location := resp.Header.Get("Location")
		msg := fmt.Sprintf("unexpected HTTP status code %d %q received, Location=%q", statusCode, statusText, location)
		twerr := twirp.NewError(twirp.Internal, msg)
		twerr = twerr.WithMeta("location", location)
		twerr = twerr.WithMeta("http_error_from_intermediary", "true")
		twerr = twerr.WithMeta("status_code", strconv.Itoa(statusCode))
		return twerr
	}

	var tj twirpErrorJSON
	d := jsonCodec.NewDecoder(resp.Body)
	if err := d.Decode(&tj); err != nil || tj.Code == "" {
		msg := fmt.Sprintf("error from intermediary with HTTP status code %d %q", statusCode, statusText)
		var code twirp.ErrorCode
		switch statusCode {
		case 400: // Bad Request
			code = twirp.Internal
		case 401: // Unauthorized
			code = twirp.Unauthenticated
		case 403: // Forbidden
			code = twirp.PermissionDenied
		case 404: // Not Found
			code = twirp.BadRoute
		case 429: // Too Many Requests
			code = twirp.ResourceExhausted
		case 502, 503, 504: // Bad Gateway, Service Unavailable, Gateway Timeout
			code = twirp.Unavailable
		default: // All other codes
			code = twirp.Unknown
		}

		twerr := twirp.NewError(code, msg)
		if err != nil {
			twerr = twirp.WrapError(twerr, err)
		}
		twerr = twerr.WithMeta("http_error_from_intermediary", "true")
		twerr = twerr.WithMeta("status_code", strconv.Itoa(statusCode))
		return twerr
	}

	errorCode := twirp.ErrorCode(tj.Code)
	if !twirp.IsValidErrorCode(errorCode) {
		msg := "invalid type returned from server error response: " + tj.Code
		return twirp.InternalError(msg)
	}

	twerr := twirp.NewError(errorCode, tj.Msg)
	for k, v := range tj.Meta {
		twerr = twerr.WithMeta(k, v)
	}
	return twerr
}

type HaberdasherTwirpService interface {
	MakeHat(context.Context, *Size) (*Hat, error)
}

type HaberdasherTwirpServer struct {
	implementation HaberdasherTwirpService
	interceptor    twirp.Interceptor
	hooks          *twirp.ServerHooks
	codecs         map[string]TwirpCodec
	handlers       map[string]func(context.Context, http.ResponseWriter, *http.Request)
	pathPrefix     string
}

func NewHaberdasherTwirpServer(implementation HaberdasherTwirpService, opts ...interface{}) *HaberdasherTwirpServer {
	serverOpts := twirp.ServerOptions{}
	twirpOpts := TwirpServerOptions{
		codecs: map[string]TwirpCodec{
			DefaultTwirpCodecJson.ContentType():     DefaultTwirpCodecJson,
			DefaultTwirpCodecProtobuf.ContentType(): DefaultTwirpCodecProtobuf,
		},
	}
	for _, opt := range opts {
		switch o := opt.(type) {
		case twirp.ServerOption:
			o(&serverOpts)
		case TwirpServerOption:
			o(&twirpOpts)
		case nil:
			continue
		default:
			panic(fmt.Sprintf("Invalid option type %T", o))
		}
	}

	pathPrefix := path.Clean(path.Join("/", serverOpts.PathPrefix(), "twitch.twirp.example.Haberdasher")) + "/"

	s := &HaberdasherTwirpServer{
		implementation: implementation,
		interceptor:    twirp.ChainInterceptors(serverOpts.Interceptors...),
		hooks:          serverOpts.Hooks,
		pathPrefix:     pathPrefix,
		codecs:         twirpOpts.codecs,
		handlers:       map[string]func(context.Context, http.ResponseWriter, *http.Request){},
	}

	s.handlers[pathPrefix+"MakeHat"] = s.callMakeHat

	return s
}

func (s *HaberdasherTwirpServer) PathPrefix() string {
	return s.pathPrefix
}

func (s *HaberdasherTwirpServer) writeError(ctx context.Context, resp http.ResponseWriter, err error) {
	twirpWriteError(ctx, resp, err, s.hooks)
}

func (s *HaberdasherTwirpServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	ctx = ctxsetters.WithPackageName(ctx, "twitch.twirp.example")
	ctx = ctxsetters.WithServiceName(ctx, "Haberdasher")
	ctx = ctxsetters.WithResponseWriter(ctx, resp)

	ctx, err := twirpCallRequestReceived(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	if req.Method != http.MethodPost {
		msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
		twerr := twirp.NewError(twirp.BadRoute, msg)
		twerr = twerr.WithMeta("twirp_invalid_route", req.Method+" "+req.URL.Path)
		s.writeError(ctx, resp, twerr)
		return
	}

	handler, ok := s.handlers[req.URL.Path]
	if !ok {
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		twerr := twirp.NewError(twirp.BadRoute, msg)
		twerr = twerr.WithMeta("twirp_invalid_route", req.Method+" "+req.URL.Path)
		s.writeError(ctx, resp, twerr)
		return
	}

	handler(ctx, resp, req)
}

func (s *HaberdasherTwirpServer) getCodec(req *http.Request) (TwirpCodec, error) {
	header := req.Header.Get("Content-Type")
	if i := strings.Index(header, ";"); i != -1 {
		header = header[:i]
	}

	header = strings.TrimSpace(strings.ToLower(header))

	codec, ok := s.codecs[header]
	if !ok || codec == nil {
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := twirp.NewError(twirp.BadRoute, msg)
		twerr = twerr.WithMeta("twirp_invalid_route", req.Method+" "+req.URL.Path)
		return nil, twerr
	}

	return codec, nil
}

func (s *HaberdasherTwirpServer) handleRequestBodyError(ctx context.Context, resp http.ResponseWriter, msg string, err error) {
	if context.Canceled == ctx.Err() {
		s.writeError(ctx, resp, twirp.NewError(twirp.Canceled, "failed to read request: context canceled"))
		return
	}

	if context.DeadlineExceeded == ctx.Err() {
		s.writeError(ctx, resp, twirp.NewError(twirp.DeadlineExceeded, "failed to read request: deadline exceeded"))
		return
	}

	twerr := twirp.WrapError(twirp.NewError(twirp.Malformed, msg), err)

	s.writeError(ctx, resp, twerr)
}

func (s *HaberdasherTwirpServer) callMakeHat(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	codec, err := s.getCodec(req)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	ctx = ctxsetters.WithMethodName(ctx, "MakeHat")
	ctx, err = twirpCallRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new(Size)

	if err := codec.UnmarshalFrom(ctx, reqContent, req.Body); err != nil {
		s.handleRequestBodyError(ctx, resp, "the request could not be decoded", err)
		return
	}

	handler := s.implementation.MakeHat
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *Size) (*Hat, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*Size)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*Size) when calling interceptor")
					}
					return s.implementation.MakeHat(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*Hat)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*Hat) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	var respContent *Hat
	func() {
		defer twirpEnsurePanicResponses(ctx, resp, s.hooks)
		respContent, err = handler(ctx, reqContent)
	}()

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *Hat and nil error while calling MakeHat. nil responses are not supported"))
		return
	}

	ctx = twirpCallResponsePrepared(ctx, s.hooks)

	buff := twirpBufferPool.Get().(*bytes.Buffer)
	defer twirpBufferPool.Put(buff)

	buff.Reset()

	if err := codec.MarshalTo(ctx, respContent, buff); err != nil {
		twerr := twirp.InternalError("failed to marshal response")
		twerr = twirp.WrapError(twerr, err)
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header()["Content-Type"] = []string{codec.ContentType()}
	resp.WriteHeader(http.StatusOK)

	if _, err := io.Copy(resp, buff); err != nil {
		msg := fmt.Sprintf("failed to write response: %s", err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = twirpCallError(ctx, s.hooks, twerr)
	}

	twirpCallResponseSent(ctx, s.hooks)
}

type HaberdasherTwirpClient struct {
	client      *http.Client
	codec       TwirpCodec
	hooks       *twirp.ClientHooks
	interceptor twirp.Interceptor
	requests    []*http.Request
}

func NewHaberdasherTwirpClient(baseUrl string, transport http.RoundTripper, opts ...interface{}) (*HaberdasherTwirpClient, error) {
	if transport == nil {
		transport = http.DefaultTransport
	}

	clientOpts := twirp.ClientOptions{}
	twirpOpts := TwirpClientOptions{
		codec: DefaultTwirpCodecProtobuf,
	}

	for _, opt := range opts {
		switch o := opt.(type) {
		case twirp.ClientOption:
			o(&clientOpts)
		case TwirpClientOption:
			o(&twirpOpts)
		case nil:
			continue
		default:
			return nil, fmt.Errorf("invalid option type %T", o)
		}
	}

	u, err := url.Parse(baseUrl)
	if err != nil {
		return nil, err
	}

	if u.Scheme == "" {
		u.Scheme = "http"
	}

	baseUrl = strings.TrimRight(u.String(), "/")

	c := HaberdasherTwirpClient{
		codec:       twirpOpts.codec,
		hooks:       clientOpts.Hooks,
		interceptor: twirp.ChainInterceptors(clientOpts.Interceptors...),
		client: &http.Client{
			Transport: transport,
			CheckRedirect: func(req *http.Request, via []*http.Request) error {
				return http.ErrUseLastResponse
			},
		},
	}

	pathPrefix := path.Clean(path.Join("/", clientOpts.PathPrefix(), "twitch.twirp.example.Haberdasher")) + "/"

	var request *http.Request

	request, err = http.NewRequest(http.MethodPost, baseUrl+pathPrefix+"MakeHat", nil)
	if err != nil {
		return nil, err
	}
	request.ContentLength = -1
	request.Header.Del("Content-Length")
	request.Header.Set("Content-Type", c.codec.ContentType())
	c.requests = append(c.requests, request)

	return &c, nil
}

func (c *HaberdasherTwirpClient) doRequest(ctx context.Context, req *http.Request, in proto.Message, out proto.Message) (context.Context, error) {
	buff := twirpBufferPool.Get().(*bytes.Buffer)
	defer twirpBufferPool.Put(buff)
	buff.Reset()

	if err := c.codec.MarshalTo(ctx, in, buff); err != nil {
		twerr := twirp.NewError(twirp.Internal, "failed to marshal request")
		twerr = twirp.WrapError(twerr, err)
		return nil, twerr
	}

	if err := ctx.Err(); err != nil {
		twerr := twirp.NewError(twirp.Internal, "aborted because context was done")
		twerr = twirp.WrapError(twerr, err)
		return nil, twerr
	}

	req = req.Clone(ctx)
	req.Body = ioutil.NopCloser(buff)

	ctx, err := twirpCallClientRequestPrepared(ctx, c.hooks, req)
	if err != nil {
		return nil, err
	}

	resp, err := c.client.Do(req)
	if err != nil {
		twerr := twirp.NewError(twirp.Internal, "failed to do request")
		twerr = twirp.WrapError(twerr, err)
		return nil, twerr
	}

	defer func() {
		_, _ = io.Copy(ioutil.Discard, resp.Body)
		_ = resp.Body.Close()
	}()

	if resp.StatusCode != http.StatusOK {
		return nil, twirpErrorFromResponse(resp)
	}

	if err := c.codec.UnmarshalFrom(ctx, out, resp.Body); err != nil {
		twerr := twirp.NewError(twirp.Internal, "failed to unmarshal response")
		twerr = twirp.WrapError(twerr, err)
		return nil, twerr
	}

	twirpCallClientResponseReceived(ctx, c.hooks)

	return ctx, nil

}

func (c *HaberdasherTwirpClient) MakeHat(ctx context.Context, in *Size) (*Hat, error) {
	ctx = ctxsetters.WithPackageName(ctx, "twitch.twirp.example")
	ctx = ctxsetters.WithServiceName(ctx, "Haberdasher")
	ctx = ctxsetters.WithMethodName(ctx, "MakeHat")

	caller := c.callMakeHat
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *Size) (*Hat, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*Size)
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*Size) when calling interceptor")
					}
					return c.callMakeHat(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*Hat)
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*Hat) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	return caller(ctx, in)

}

func (c *HaberdasherTwirpClient) callMakeHat(ctx context.Context, in *Size) (*Hat, error) {
	req := c.requests[0]
	out := new(Hat)

	ctx, err := c.doRequest(ctx, req, in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		twirpCallClientError(ctx, c.hooks, twerr)
		return nil, err
	}

	twirpCallClientResponseReceived(ctx, c.hooks)

	return out, nil
}
