// Code generated by protoc-gen-twirp-go DO NOT EDIT.
package {{ .Package }}

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strconv"
	"strings"
	"sync"

	"github.com/twitchtv/twirp"
	"github.com/twitchtv/twirp/ctxsetters"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	jsoniter "github.com/json-iterator/go"
)

var jsonCodec = jsoniter.ConfigCompatibleWithStandardLibrary

var twirpBufferPool = sync.Pool {
	New: func() interface{} {
		return &bytes.Buffer{}
	},
}

type TwirpCodec interface {
	ContentType() string
	MarshalTo(context.Context, proto.Message, io.Writer) error
	UnmarshalFrom(context.Context, proto.Message, io.Reader) error
}

type TwirpCodecProtobuf struct {
	proto.UnmarshalOptions
	proto.MarshalOptions
}

var DefaultTwirpCodecProtobuf = &TwirpCodecProtobuf{
}

func (t *TwirpCodecProtobuf)ContentType() string {
	return "application/protobuf"
}

func (t *TwirpCodecProtobuf)MarshalTo(_ context.Context, m proto.Message, w io.Writer) error {
	data, err := t.MarshalOptions.Marshal(m)
	if err != nil {
		return err
	}

	_, err = w.Write(data)
	return err
}

func (t *TwirpCodecProtobuf)UnmarshalFrom(_ context.Context, m proto.Message, r io.Reader) error {
	buff := twirpBufferPool.Get().(*bytes.Buffer)
	defer twirpBufferPool.Put(buff)

	buff.Reset()

	if _, err := io.Copy(buff, r); err != nil {
		return err
	}

	return t.UnmarshalOptions.Unmarshal(buff.Bytes(), m)
}

type TwirpCodecJson struct {
	protojson.MarshalOptions
	protojson.UnmarshalOptions
}

var DefaultTwirpCodecJson = &TwirpCodecJson{
	MarshalOptions: protojson.MarshalOptions {
		UseProtoNames: true,
		EmitUnpopulated: true,
	},
}


func (t *TwirpCodecJson)ContentType() string {
	return "application/json"
}

func (t *TwirpCodecJson)MarshalTo(_ context.Context, m proto.Message, w io.Writer) error {
	data, err := t.MarshalOptions.Marshal(m)
	if err != nil {
		return err
	}

	_, err = w.Write(data)
	return err
}

func (t *TwirpCodecJson)UnmarshalFrom(_ context.Context, m proto.Message, r io.Reader) error {
	buff := twirpBufferPool.Get().(*bytes.Buffer)
	defer twirpBufferPool.Put(buff)

	buff.Reset()

	if _, err := io.Copy(buff, r); err != nil {
		return err
	}

	return t.UnmarshalOptions.Unmarshal(buff.Bytes(), m)
}

type TwirpServerOptions struct {
	codecs map[string]TwirpCodec
}

type TwirpServerOption func(*TwirpServerOptions)

func WithTwirpServerCodec(codec TwirpCodec) TwirpServerOption {
	return func(o *TwirpServerOptions) {
		o.codecs[codec.ContentType()] = codec
	}
}

type TwirpClientOptions struct {
	codec TwirpCodec
}

type TwirpClientOption func(*TwirpClientOptions)

func WithTwirpClientCodec(codec TwirpCodec) TwirpClientOption {
	return func(o *TwirpClientOptions) {
		o.codec = codec
	}
}

func twirpCallRequestReceived(ctx context.Context, h *twirp.ServerHooks) (context.Context, error) {
	if h == nil || h.RequestReceived == nil {
		return ctx, nil
	}
	return h.RequestReceived(ctx)
}

func twirpCallRequestRouted(ctx context.Context, h *twirp.ServerHooks) (context.Context, error) {
	if h == nil || h.RequestRouted == nil {
		return ctx, nil
	}
	return h.RequestRouted(ctx)
}

func twirpErrFromPanic(p interface{}) error {
	if err, ok := p.(error); ok {
		return err
	}
	return fmt.Errorf("panic: %v", p)
}

func twirpPanicInterceptor(method twirp.Method) twirp.Method {
	return func(ctx context.Context, request interface{}) (resp interface{}, err error) {
		defer func() {
			if r := recover(); r != nil {
				panicError := twirpErrFromPanic(r)
				twerr := twirp.NewError(twirp.Internal, "internal service panic")
				twerr = twerr.WithMeta("cause", panicError.Error())
				
				resp = nil
				err = twerr
			}
		}()

		resp, err = method(ctx, request)
		return resp, err
	}
}

func twirpContextInterceptor(method twirp.Method) twirp.Method {
	return func(ctx context.Context, request interface{}) (interface{}, error) {
		resp, err := method(ctx, request)
		
		if errors.Is(err, context.Canceled) {
			twerr := twirp.NewError(twirp.Canceled, "context cancelled")
			twerr = twerr.WithMeta("cause", err.Error())
			return nil, twerr
		}

		if errors.Is(err, context.DeadlineExceeded) {
			twerr := twirp.NewError(twirp.DeadlineExceeded, "context deadline exceeded")
			twerr = twerr.WithMeta("cause", err.Error())
			return nil, twerr
		}

		return resp, err
	}
}


func twirpWriteError(ctx context.Context, resp http.ResponseWriter, err error, hooks *twirp.ServerHooks) {
	twerr, ok := err.(twirp.Error)
	if !ok {
		twerr = twirp.InternalErrorWith(err)
	}

	statusCode := twirp.ServerHTTPStatusFromErrorCode(twerr.Code())
	ctx = ctxsetters.WithStatusCode(ctx, statusCode)
	ctx = twirpCallError(ctx, hooks, twerr)

	respBody := twirpMarshalErrorToJSON(twerr)

	resp.Header()["Content-Type"] = []string{"application/json"}
	resp.WriteHeader(statusCode) 

	_, _ = resp.Write(respBody)

	twirpCallResponseSent(ctx, hooks)
}

func twirpCallError(ctx context.Context, h *twirp.ServerHooks, err twirp.Error) context.Context {
	if h == nil || h.Error == nil {
		return ctx
	}
	return h.Error(ctx, err)
}

func twirpCallResponseSent(ctx context.Context, h *twirp.ServerHooks) {
	if h == nil || h.ResponseSent == nil {
		return
	}
	h.ResponseSent(ctx)
}

type twirpErrorJSON struct {
	Meta map[string]string `json:"meta,omitempty"`
	Code string            `json:"code"`
	Msg  string            `json:"msg"`
}

func twirpMarshalErrorToJSON(twerr twirp.Error) []byte {
	// make sure that msg is not too large
	msg := twerr.Msg()
	if len(msg) > 1e6 {
		msg = msg[:1e6]
	}

	tj := twirpErrorJSON{
		Code: string(twerr.Code()),
		Msg:  msg,
		Meta: twerr.MetaMap(),
	}

	buf, err := jsonCodec.Marshal(&tj)
	if err != nil {
		buf = []byte("{\"type\": \"" + twirp.Internal + "\", \"msg\": \"There was an error but it could not be serialized into JSON\"}") // fallback
	}

	return buf
}

func twirpCallResponsePrepared(ctx context.Context, h *twirp.ServerHooks) context.Context {
	if h == nil || h.ResponsePrepared == nil {
		return ctx
	}
	return h.ResponsePrepared(ctx)
}

func twirpCallClientResponseReceived(ctx context.Context, h *twirp.ClientHooks) {
	if h == nil || h.ResponseReceived == nil {
		return
	}
	h.ResponseReceived(ctx)
}

func twirpCallClientRequestPrepared(ctx context.Context, h *twirp.ClientHooks, req *http.Request) (context.Context, error) {
	if h == nil || h.RequestPrepared == nil {
		return ctx, nil
	}
	return h.RequestPrepared(ctx, req)
}

func twirpCallClientError(ctx context.Context, h *twirp.ClientHooks, err twirp.Error) {
	if h == nil || h.Error == nil {
		return
	}
	h.Error(ctx, err)
}

func twirpErrorFromResponse(resp *http.Response) twirp.Error {
	statusCode := resp.StatusCode
	statusText := http.StatusText(statusCode)

	if statusCode >= 300 && statusCode <= 399 {
		location := resp.Header.Get("Location")
		msg := fmt.Sprintf("unexpected HTTP status code %d %q received, Location=%q", statusCode, statusText, location)
		twerr := twirp.NewError(twirp.Internal, msg)
		twerr = twerr.WithMeta("location", location)
		twerr = twerr.WithMeta("http_error_from_intermediary", "true") 
		twerr = twerr.WithMeta("status_code", strconv.Itoa(statusCode))
		return twerr
	}

	var tj twirpErrorJSON
	d := jsonCodec.NewDecoder(resp.Body)
	if err := d.Decode(&tj); err != nil || tj.Code == "" {
		msg := fmt.Sprintf("error from intermediary with HTTP status code %d %q", statusCode, statusText)
		var code twirp.ErrorCode
		switch statusCode {
			case 400: // Bad Request
				code = twirp.Internal
			case 401: // Unauthorized
				code = twirp.Unauthenticated
			case 403: // Forbidden
				code = twirp.PermissionDenied
			case 404: // Not Found
				code = twirp.BadRoute
			case 429: // Too Many Requests
				code = twirp.ResourceExhausted
			case 502, 503, 504: // Bad Gateway, Service Unavailable, Gateway Timeout
				code = twirp.Unavailable
			default: // All other codes
				code = twirp.Unknown
		}

		twerr := twirp.NewError(code, msg)
		if err != nil {
			twerr = twirp.WrapError(twerr, err)
		}
		twerr = twerr.WithMeta("http_error_from_intermediary", "true") 
		twerr = twerr.WithMeta("status_code", strconv.Itoa(statusCode))
		return twerr
	}

	errorCode := twirp.ErrorCode(tj.Code)
	if !twirp.IsValidErrorCode(errorCode) {
		msg := "invalid type returned from server error response: " + tj.Code
		return twirp.InternalError(msg)
	}

	twerr := twirp.NewError(errorCode, tj.Msg)
	for k, v := range tj.Meta {
		twerr = twerr.WithMeta(k, v)
	}
	return twerr
}

{{ $package := .Name }}

{{ range $service := .Services }}
type {{ .GoName }}TwirpService interface {
	{{range $method := .Methods }}	
	{{ .GoName}}(context.Context, *{{ .Input }}) (*{{ .Output }}, error)
	{{ end }}
} 

type {{ .GoName }}TwirpServer struct {
	implementation {{ .GoName }}TwirpService
	interceptor twirp.Interceptor
	hooks *twirp.ServerHooks
	codecs map[string]TwirpCodec
	handlers map[string]func(context.Context, http.ResponseWriter, *http.Request)
	pathPrefix string
}

func New{{ .GoName }}TwirpServer(implementation {{ .GoName }}TwirpService, opts ...interface{}) *{{ .GoName }}TwirpServer {
	serverOpts := twirp.ServerOptions{}
	twirpOpts := TwirpServerOptions{
		codecs: map[string]TwirpCodec{
			DefaultTwirpCodecJson.ContentType(): DefaultTwirpCodecJson,
			DefaultTwirpCodecProtobuf.ContentType(): DefaultTwirpCodecProtobuf,
		},
	}
	for _, opt := range opts {
		switch o := opt.(type) {
		case twirp.ServerOption:
			o(&serverOpts)
		case TwirpServerOption: 
			o(&twirpOpts)
		case nil:
			continue
		default:
			panic(fmt.Sprintf("Invalid option type %T", o))
		}
	}

	pathPrefix := path.Clean(path.Join("/", serverOpts.PathPrefix(), "{{ $package }}.{{ .Name }}")) + "/"

	var interceptors []twirp.Interceptor
	for _, interceptor := range serverOpts.Interceptors {
		interceptors = append(interceptors, interceptor)
	}

	interceptors = append(interceptors, twirpPanicInterceptor)
	interceptors = append(interceptors, twirpContextInterceptor)

	s:= &{{ .GoName }}TwirpServer{
		implementation: implementation,
		interceptor: twirp.ChainInterceptors(interceptors...),
		hooks: serverOpts.Hooks,
		pathPrefix: pathPrefix,
		codecs: twirpOpts.codecs,
		handlers: map[string]func(context.Context, http.ResponseWriter, *http.Request){},
	}

	{{range $method := .Methods }}
	s.handlers[pathPrefix + "{{ .Name }}"] = s.call{{ .Name }}
	{{ end }}
	
	return s
}

func (s *{{ .GoName }}TwirpServer)PathPrefix() string {
	return s.pathPrefix
}

func (s *{{ .GoName }}TwirpServer)writeError(ctx context.Context, resp http.ResponseWriter, err error) {
	twirpWriteError(ctx, resp, err, s.hooks)
}

func (s *{{ .GoName }}TwirpServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	ctx := req.Context()
	ctx = ctxsetters.WithPackageName(ctx, "{{ $package }}")
	ctx = ctxsetters.WithServiceName(ctx, "{{ .Name }}")
	ctx = ctxsetters.WithResponseWriter(ctx, resp)

	ctx, err := twirpCallRequestReceived(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	if req.Method != http.MethodPost {
		msg := fmt.Sprintf("unsupported method %q (only POST is allowed)", req.Method)
		twerr := twirp.NewError(twirp.BadRoute, msg)
		twerr = twerr.WithMeta("twirp_invalid_route", req.Method + " " + req.URL.Path)
		s.writeError(ctx, resp, twerr)
		return
	}

	handler, ok := s.handlers[req.URL.Path]
	if !ok {
		msg := fmt.Sprintf("no handler for path %q", req.URL.Path)
		twerr := twirp.NewError(twirp.BadRoute, msg)
		twerr = twerr.WithMeta("twirp_invalid_route", req.Method + " " + req.URL.Path)
		s.writeError(ctx, resp, twerr)
		return
	}
	

	handler(ctx, resp, req)
}

func (s *{{ $service.GoName }}TwirpServer)getCodec(req *http.Request)(TwirpCodec, error) {
	header := req.Header.Get("Content-Type")
	if i := strings.Index(header, ";"); i != -1 {
		header = header[:i]
	}

	header = strings.TrimSpace(strings.ToLower(header))

	codec, ok := s.codecs[header]
	if !ok || codec == nil {
		msg := fmt.Sprintf("unexpected Content-Type: %q", req.Header.Get("Content-Type"))
		twerr := twirp.NewError(twirp.BadRoute, msg)
		twerr = twerr.WithMeta("twirp_invalid_route", req.Method + " " + req.URL.Path)
		return nil, twerr
	}

	return codec, nil
}

{{range $method := .Methods }}	
func (s *{{ $service.GoName }}TwirpServer)call{{ .GoName }}(ctx context.Context, resp http.ResponseWriter, req *http.Request) {
	codec, err := s.getCodec(req)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	ctx = ctxsetters.WithMethodName(ctx, "{{ .GoName }}")
	ctx, err = twirpCallRequestRouted(ctx, s.hooks)
	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	reqContent := new({{ .Input }})

	if err := codec.UnmarshalFrom(ctx, reqContent, req.Body); err != nil {
		twerr := twirp.NewError(twirp.Malformed, "the request could not be decoded")
		twerr = twerr.WithMeta("cause", err.Error())
		s.writeError(ctx, resp, twerr)
		return
	}

	handler := s.implementation.{{ .GoName }}
	if s.interceptor != nil {
		handler = func(ctx context.Context, req *{{ .Input }}) (*{{ .Output }}, error) {
			resp, err := s.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*{{ .Input }})
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*{{ .Input }}) when calling interceptor")
					}
					return s.implementation.{{ .GoName }}(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*{{ .Output }})
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*{{ .Output }}) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	respContent, err := handler(ctx, reqContent)

	if err != nil {
		s.writeError(ctx, resp, err)
		return
	}

	if respContent == nil {
		s.writeError(ctx, resp, twirp.InternalError("received a nil *{{ .Output }} and nil error while calling {{ .GoName }}. nil responses are not supported"))
		return
	}

	ctx = twirpCallResponsePrepared(ctx, s.hooks)

	buff := twirpBufferPool.Get().(*bytes.Buffer)
	defer twirpBufferPool.Put(buff)

	buff.Reset()

	if err := codec.MarshalTo(ctx, respContent, buff); err != nil {
		twerr := twirp.InternalError("failed to marshal response")
		twerr = twirp.WrapError(twerr, err)
		s.writeError(ctx, resp, twerr)
		return
	}

	ctx = ctxsetters.WithStatusCode(ctx, http.StatusOK)
	resp.Header()["Content-Type"] = []string{codec.ContentType()}
	resp.WriteHeader(http.StatusOK)

	if _, err := io.Copy(resp, buff); err != nil {
		msg := fmt.Sprintf("failed to write response: %s", err.Error())
		twerr := twirp.NewError(twirp.Unknown, msg)
		ctx = twirpCallError(ctx, s.hooks, twerr)
	}

	twirpCallResponseSent(ctx, s.hooks)
}
{{ end }}

type {{ .GoName }}TwirpClient struct {
	client *http.Client
	codec TwirpCodec
	hooks *twirp.ClientHooks
	interceptor twirp.Interceptor
	requests []*http.Request
}

func New{{ .GoName }}TwirpClient(baseUrl string, transport http.RoundTripper, opts ...interface{}) (*{{ .GoName }}TwirpClient, error) {
	if transport == nil {
		transport = http.DefaultTransport
	}

	clientOpts := twirp.ClientOptions{}
	twirpOpts := TwirpClientOptions{
		codec: DefaultTwirpCodecProtobuf,
	}

	for _, opt := range opts {
		switch o := opt.(type) {
		case twirp.ClientOption:
			o(&clientOpts)
		case TwirpClientOption: 
			o(&twirpOpts)
		case nil:
			continue
		default:
			return nil, fmt.Errorf("invalid option type %T", o)
		}
	}

	u, err := url.Parse(baseUrl)
	if err != nil {
		return nil, err
	}

	if u.Scheme == "" {
		u.Scheme = "http"
	}

	baseUrl = strings.TrimRight(u.String(), "/")

	c := {{ .GoName }}TwirpClient{
		codec: twirpOpts.codec,
		hooks: clientOpts.Hooks,
		interceptor: twirp.ChainInterceptors(clientOpts.Interceptors...),
		client: &http.Client{ 
			Transport: transport,
			CheckRedirect: func(req *http.Request, via []*http.Request) error {
				return http.ErrUseLastResponse
			},
		},
	}

	pathPrefix := path.Clean(path.Join("/", clientOpts.PathPrefix(), "{{ $package }}.{{ $service.Name }}")) + "/"

	var	request *http.Request

	{{ range $method := .Methods }}
	request, err = http.NewRequest(http.MethodPost, baseUrl + pathPrefix + "{{ $method.GoName }}", nil)
	if err != nil {
		return nil, err
	}
	request.ContentLength = -1
	request.Header.Del("Content-Length")
	request.Header.Set("Content-Type", c.codec.ContentType())
	c.requests = append(c.requests, request)
	{{ end }}
	
	return &c, nil
}

func (c *{{ $service.GoName }}TwirpClient)doRequest(ctx context.Context, req *http.Request, in proto.Message, out proto.Message) (context.Context, error) {
	buff := twirpBufferPool.Get().(*bytes.Buffer)
	defer twirpBufferPool.Put(buff)
	buff.Reset()
	
	if err := c.codec.MarshalTo(ctx, in, buff); err != nil {
		twerr := twirp.NewError(twirp.Internal, "failed to marshal request")
		twerr = twirp.WrapError(twerr, err)
		return nil, twerr
	}

	if err := ctx.Err(); err != nil {
		twerr := twirp.NewError(twirp.Internal, "aborted because context was done")
		twerr = twirp.WrapError(twerr, err)
		return nil, twerr
	}

	req = req.Clone(ctx)
	req.Body = ioutil.NopCloser(buff)

	ctx, err := twirpCallClientRequestPrepared(ctx, c.hooks, req)
	if err != nil {
		return nil, err
	}

	resp, err := c.client.Do(req)
	if err != nil {
		twerr := twirp.NewError(twirp.Internal, "failed to do request")
		twerr = twirp.WrapError(twerr, err)
		return nil, twerr
	}

	defer func() {
		_, _ = io.Copy(ioutil.Discard, resp.Body)
		_ = resp.Body.Close()
	}()

	if resp.StatusCode != http.StatusOK {
		return nil, twirpErrorFromResponse(resp)
	}

	if err := c.codec.UnmarshalFrom(ctx, out, resp.Body, ); err != nil {
		twerr := twirp.NewError(twirp.Internal, "failed to unmarshal response")
		twerr = twirp.WrapError(twerr, err)
		return nil, twerr
	}

	twirpCallClientResponseReceived(ctx, c.hooks)

	return ctx, nil
	
}

{{ range $index, $method := .Methods }}
func (c *{{ $service.GoName }}TwirpClient){{ .GoName }}(ctx context.Context, in *{{ .Input }}) (*{{ .Output }}, error) {
	ctx = ctxsetters.WithPackageName(ctx, "{{ $package }}")
	ctx = ctxsetters.WithServiceName(ctx, "{{ $service.Name }}")
	ctx = ctxsetters.WithMethodName(ctx, "{{ .Name }}")

	caller := c.call{{ .GoName }}
	if c.interceptor != nil {
		caller = func(ctx context.Context, req *{{ .Input}}) (*{{ .Output }}, error) {
			resp, err := c.interceptor(
				func(ctx context.Context, req interface{}) (interface{}, error) {
					typedReq, ok := req.(*{{ .Input}})
					if !ok {
						return nil, twirp.InternalError("failed type assertion req.(*{{ .Input}}) when calling interceptor")
					}
					return c.call{{ .GoName }}(ctx, typedReq)
				},
			)(ctx, req)
			if resp != nil {
				typedResp, ok := resp.(*{{ .Output }})
				if !ok {
					return nil, twirp.InternalError("failed type assertion resp.(*{{ .Output }}) when calling interceptor")
				}
				return typedResp, err
			}
			return nil, err
		}
	}

	return caller(ctx, in)
	
}

func (c *{{ $service.GoName }}TwirpClient)call{{ .GoName }}(ctx context.Context, in *{{ .Input }}) (*{{ .Output }}, error) {
	req := c.requests[{{ $index }}]
	out := new({{.Output}})

	ctx, err := c.doRequest(ctx, req, in, out)
	if err != nil {
		twerr, ok := err.(twirp.Error)
		if !ok {
			twerr = twirp.InternalErrorWith(err)
		}
		twirpCallClientError(ctx, c.hooks, twerr)
		return nil, err
	}

	twirpCallClientResponseReceived(ctx, c.hooks)

	return out, nil	
}

{{ end }}

{{ end }}
